Minimum Insertions to Make String Palindrome
===========================================

Intuition:
----------
A palindrome reads the same forwards and backwards. To make any string a palindrome with minimum insertions:
1. We need to balance the characters on both sides
2. The optimal solution relates to the longest palindromic subsequence (LPS) already present in the string
3. Minimum insertions = Length of string - Length of LPS

Basic Approach:
--------------
1. Find the longest palindromic subsequence in the string
2. Characters not part of this subsequence will need matching pairs
3. Each such character requires one insertion

Dynamic Programming Approach:
----------------------------
1. Create a DP table where dp[i][j] represents the minimum insertions needed for substring s[i..j]
2. Base cases:
   - Single character: 0 insertions needed (already palindrome)
   - Empty string: 0 insertions
3. Recurrence relation:
   - If s[i] == s[j]: 
     dp[i][j] = dp[i+1][j-1] (no insertion needed for these characters)
   - Else:
     dp[i][j] = 1 + min(dp[i+1][j], dp[i][j-1]) (insert either left or right character)

Example Walkthrough:
--------------------
String: "abca"

1. Compare first and last characters ('a' and 'a') - they match
   - Move inside: "bc"
2. Compare 'b' and 'c' - don't match
   - Option 1: Insert 'c' after 'b' ("b c b c") - cost 1
   - Option 2: Insert 'b' before 'c' ("b c b") - cost 1
3. Minimum insertions: 1 (final palindrome: "abcba" or "acbca")

Time Complexity: O(n^2) where n is string length
Space Complexity: O(n^2) for DP table

C++ Implementation:
-------------------
#include <iostream>
#include <vector>
#include <algorithm>
using namespace std;

int minInsertions(string s) {
    int n = s.length();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    
    for (int len = 2; len <= n; ++len) {
        for (int i = 0; i <= n - len; ++i) {
            int j = i + len - 1;
            if (s[i] == s[j]) {
                dp[i][j] = dp[i+1][j-1];
            } else {
                dp[i][j] = 1 + min(dp[i+1][j], dp[i][j-1]);
            }
        }
    }
    
    return dp[0][n-1];
}

int main() {
    string s = "abca";
    cout << "Minimum insertions needed: " << minInsertions(s) << endl;
    return 0;
}

Optimization:
------------
The space complexity can be optimized to O(n) by using a 1D DP array since we only need the previous diagonal values.

Alternative Approach:
---------------------
This problem can also be solved by:
1. Finding the length of the longest palindromic subsequence (LPS)
2. Minimum insertions = n - LPS length
